## 1. 요약 (Summary)
ROS2 Interface 통합 구현(Hangman), 비동기 통신(Asynchronous Communication), MultiThreadedExecutor, Custom Interface 최적화, Docker 기초
**작성자:** MARKCH
**날짜:** 2025년 12월 25일
**주제:** ROS2 인터페이스 프로그래밍 응용 실습 (Hangman Game Project)


## 2. 일일 목표 및 계획 (Daily Goals & Plan)
- **메인 목표**: ROS2 인터페이스 프로그래밍 응용 실습 (Hangman Game Project)
- **상세 목표**:
  - Topic, Service, Action을 복합적으로 활용한 노드 설계 및 구현
  - `my_robot_system` (관리, 센서, 쿨러, 스위치) 커스텀 패키지 구현 및 디버깅
  - Docker 튜토리얼 기초 학습 완료
- **총 학습 시간**: 약 7시간

## 3. 수행 작업 내용 (Work Performed)
### 코드 개발/구현
- **구현 1: Hangman 게임 아키텍처 구축**
  - **Letter Publisher**: `letter_topic`을 통해 알파벳(a-z)을 1초 간격으로 발행하는 Timer 기반 로직 구현.
  - **Word Service**: 임의의 단어를 선정하고, Client(`user_input`)의 요청(`CheckLetter`)에 따라 정답 여부를 판별하여 `progress` 토픽 발행.
  - **Action Server/Client**: 게임 진행 상황(남은 기회, 종료 여부)을 관리하고 피드백을 주고받는 Action 인터페이스(`GameProgress.action`) 구현.

- **구현 2: 비동기 요청 처리 및 사용자 입력 처리**
  - **User Input**: `user_input.py`에서 `threading` 모듈을 사용하여 사용자 입력을 대기(Blocking)하면서도 ROS2 통신이 유지되도록 설계. Request 데이터 자체는 비어있으나(`Empty`), 내부 트리거로 동작 수행.
  - **Action Flow**: Action Client에서 `send_goal_async`로 목표 전송 후, `future` 객체를 추적하여 `get_result_async`로 최종 결과를 수신하는 비동기 체인 구현.

- **구현 3: Custom Robot System (my_robot_system)**
  - PDF 실습 외 추가 구현 진행.
  - **Manage Node**를 중심으로 **Sensor Node**, **Cooler Node**, **Switch Action Node** 간의 데이터 흐름 및 제어 로직 설계.
  - 각 노드 간 통신 인터페이스 정의 및 데이터 처리 흐름 최적화 (Interface Debugging).

### 디버깅 및 테스트
- **테스트 환경**: Ubuntu 22.04.5, ROS2 Humble, CPU i7, GPU 1060, RAM 8GB
- **이슈 해결**:
  - **Action Server 병렬 처리**: `progress` 토픽 구독과 Action Goal 처리가 동시에 이루어져야 하므로 `MultiThreadedExecutor` 적용 필요성 확인 및 구현.
  - **Client 실행 방식 변경**: Action Client의 경우 단순 `spin` 대신, 결과 수신 후 종료를 위해 `while rclpy.ok()` 루프 내에서 `spin_once`를 사용하는 패턴 적용.

### 학습 및 연구
- **ROS2 Interface 패턴**: Topic(단방향/지속성), Service(양방향/일회성), Action(양방향/지속성/피드백)의 차이점과 복합 사용 사례 체득.
- **Python Callback**: `add_done_callback` 등 콜백 함수 등록 시 괄호 `()` 없이 함수명(참조)만 전달해야 함을 재확인.

## 4. 문제점 및 해결 과정 (Issues & Solutions)
- **문제점 1: 비동기 함수 용어 혼동**
  - **현상**: Service의 `call_async`, Action의 `send_goal_async`, `get_result_async` 간의 역할 및 반환 객체 혼동.
  - **원인 및 해결**: 각 메서드가 반환하는 `Future` 객체의 역할 정의.
    - `call_async`: 서비스 응답 대기.
    - `send_goal_async`: 액션 서버의 Goal 수락 여부 대기.
    - `get_result_async`: 액션 완료 후 최종 결과값 대기.

- **문제점 2: 실행자(Executor) 블로킹 현상**
  - **현상**: Action Server에서 토픽 콜백 처리 중 액션 요청이 지연되거나 처리되지 않음.
  - **원인 및 해결**: 기본 `SingleThreadedExecutor`는 한 번에 하나의 콜백만 처리. `MultiThreadedExecutor` 도입 및 필요시 `CallbackGroup` 설정을 통해 병렬 처리 구조로 개선.

- **문제점 3: Custom Interface 데이터 타입 통신 오류**
  - **현상**: `my_robot_system` 구현 중 `Switch` 액션 통신이 원활하지 않고 데이터 처리 지연 발생.
  - **원인 및 해결**:
    - 초기 설계 시 `string[] turn_on` 형태로 인터페이스를 정의했으나, 단순 On/Off 제어에 불필요한 직렬화 오버헤드 및 복잡성 유발.
    - 인터페이스 정의를 `bool turn_on`으로 변경하여 데이터 구조를 경량화.
    - 변경 후 통신 성공률 향상 및 원활한 제어 흐름 확인.

## 5. 배운점 및 다음 단계 (Learned & Next Steps)
- **배운점**:
  - **Future 객체 추적**: 비동기 프로그래밍에서 요청의 상태를 추적하고, 콜백 체인을 통해 결과를 처리하는 흐름의 중요성 이해.
  - **ROS2 Threading**: 노드 내에서 사용자 입력(`input()`)과 같은 블로킹 작업이 필요할 때 별도 스레드를 분리해야 메인 ROS 루프가 멈추지 않음.
  - **Interface Design**: 인터페이스 설계 시 목적에 맞는 최소한의 데이터 타입을 사용하여 통신 효율성을 높여야 함.
- **다음 단계**:
  - `my_robot_system`의 노드 간 통신 안정화 및 `CallbackGroup` 세부 설정 테스트.
  - Docker 컨테이너 내에서 ROS2 노드 통신 환경 구축 심화 학습.

## 6. 레퍼런스 (References)

- **Commit Hash**: topic, service, action을 활용하여 hangman game 구현, my_robot_system 구현, docker tutorial 진행
- **src**: 
  - [HangMan Game Test](../../src/2025_12_26_1_HangMan_game_Test.png)
  - [My Robot System Interface Check](../../src/2025_12_26_2_My_Robot_System_Interface_Check.png)
  - [Practice2 Error Analysis](../../src/2025_12_26_3_Practice2_Error_Analysis.webm)
  - [ROSGraph Hangman Games](../../src/2025_12_26_4_ROSGraph_Hangman_Games.png)
  - [Docker Tutorial](../../src/2025_12_26_5_Docker_Tutorial.png)
