# [일일 개발 보고서] 노드 생존 신호 모니터링 시스템 구축

## 1. 요약 (Summary)
금일은 로봇 제어 시스템의 안정성 확보를 위해 노드 생존 신고(Alive Signal)를 확인하는 신규 노드를 성공적으로 구현하였습니다. 개발 과정에서 발생한 빌드 아티팩트 누락, 동시성 처리에 따른 기아 상태(Starvation), 인터페이스 의존성 이슈 등 5가지 주요 기술적 난제를 해결하였으며, 이를 통해 소프트웨어 생명주기(SDLC)와 컴포넌트 기반 개발(CBSE) 원칙을 재확인하고 시스템의 견고함을 확보하였습니다.

## 2. 문제 인식 (Problem Identification)
* **생존 신호 불안정:** `robot_control` 노드가 시스템 활성 상태를 알리는 `alive` 메시지를 발행하던 중, 다른 명령어 입력 시 Publish가 중단되는 현상이 발생하여 시스템 상태 모니터링에 공백이 생김.
* **통합 후 회귀 오류:** 신규 기능(모니터링 노드 등)을 통합하는 과정에서 기존에 정상 작동하던 `robot_control` 노드의 서비스 서버 기능이 멈추거나 응답하지 않는 현상 식별.

## 3. 접근 방식 (Approach)
* **인터페이스 고도화:** 기존 표준 인터페이스의 한계로 판단하여, 모니터링 목적에 최적화된 **사용자 지정 인터페이스(Custom Interface)**를 설계하여 적용.

* **컴포넌트 기반 설계:** ROS 2 패키지 시스템을 컨테이너 시스템으로 간주하고, 인터페이스와 비즈니스 로직을 분리하는 **컴포넌트 기반 개발(CBSE)** 방법론을 채택하여 의존성을 관리.

## 4. 해결 (Solution)
* **사용자 지정 인터페이스 적용:** 독자적인 인터페이스 패키지를 구축하고, 이를 `robot_control` 및 신규 모니터링 노드에 적용하여 명령어 입력 중에도 끊김 없는 생존 신호 발행 성공.
* **빌드 파이프라인 정립:** 인터페이스 패키지가 독립된 모듈(Artifact)로 먼저 빌드되어야 함을 파악하고, 패키지 재설치 및 소싱(Sourcing)을 통해 의존성 문제를 해결.

## 5. 기반 기술 및 인사이트 (Foundational Technology)
* **Software Development Life Cycle (SDLC):** 구현(Implementation) → 빌드(Build) → 배포(Deployment) → 실행(Execution)의 표준 프로세스 준수
* **Concurrency Control:** 단일 스레드(Single Thread) 환경에서의 Non-blocking I/O 처리를 통한 기아 상태(Starvation) 방지
* **Component-Based Software Engineering (CBSE):** 모듈화(Modularity)와 추상화를 통한 시스템 결합도 완화

## 6. 트러블 슈팅 (Troubleshooting Log)

보고서에 기록된 주요 기술적 이슈 5가지를 해결하였습니다.

1. **실행 파일 부재 (No executable found)**
    * **원인:** 소스 코드 수정 후 **빌드 단계를 누락**하고 실행을 시도한 SDLC 위반 및 형상관리(SCM) 실패.
    * **조치:** 코드 수정 후 반드시 빌드 아티팩트(실행 파일)를 생성하는 프로세스 확립
    * **의의:** SDLC의 구현, 빌드, 배포, 실행 단계를 포함한 SDLC의 이해

2. **노드 통합 후 회귀 오류 (Regression)**
    * **원인:** 신규 컴포넌트(`describer` 등) 추가 후 시스템 자원이나 의존성 영향으로 기존 노드(`robot_control`) 기능 정지.
    * **조치:** 통합 테스트를 통해 의존성 충돌 확인 및 격리 조치.
    * **의의:** 컨테이너 모델의 소스, 빌드, 배포 및 추상화와 모듈화에 대한 이해

3. **동시성 기아 상태 (Starvation)**
    * **원인:** 단일 스레드 노드에서 **동기식(Blocking) 서비스 요청**이 실행 흐름을 독점하여, Topic 발행 루틴이 실행되지 못하는 현상.
    * **조치:** Blocking I/O를 Non-blocking 방식(비동기 호출)으로 변경하여 실행 흐름 개선.
    * **의의:** add_done_callback함수, multi-threaded executor를 활용하여 동기, 비동기에 대한 이해

4. **종료 처리 결함 (Zombie Process)**
    * **원인:** `rclpy.shutdown()`(시스템 종료)을 `node.destroy_node()`(객체 반납)보다 먼저 호출하여 노드가 고립됨.
    * **조치:** 종료 시퀀스 순서를 `destroy` → `shutdown`으로 교정하여 리소스 누수 방지.

5. **인터페이스 빌드 이슈 (Import Error)**
    * **원인:** 인터페이스 변경 후, 이를 참조하는 `detection.py`에서 참조 불가 에러 발생. 인터페이스 패키지의 빌드가 선행되지 않음.
    * **조치:** 인터페이스 패키지를 우선 빌드하여 아티팩트를 생성한 후, 노드 패키지에서 참조하도록 수정.
    * **의의:** 컨테이너 모델의 소스, 빌드, 배포 및 추상화와 모듈화에 대한 이해
    
## 7. 레퍼런스
* **commit:** 노드의 생명주기를 확인할 수 있는 새로운 노드 구현
* **src:**
  * [Custom Interface Definition](../src/Project_CV_Motion/2026_02_01_1_Custom_Interface_SrvDepthPosition.png)
  * [Concurrency Control Demo](../src/Project_CV_Motion/2026_02_01_2_Topic_Service_Concurrency_Control.mp4)

* **url:**
  * [10 Common Software Architectural Patterns](https://mingrammer.com/translation-10-common-software-architectural-patterns-in-a-nutshell/)
  * [Tistory Reference](https://august-jhy.tistory.com/45#google_vignette)
  * [What is a Container?](https://www.samsungsds.com/kr/cloud-glossary/what-is-a-container.html)